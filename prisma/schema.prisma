generator client {
  provider        = "prisma-client-js"
  binaryTargets   = ["native", "linux-musl"]
  previewFeatures = ["interactiveTransactions"]
}

datasource db {
  provider          = "mysql"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

model Address {
  id           String                    @id @default(dbgenerated("(uuid())"))
  address      String                    @unique @db.VarChar(255)
  createdAt    DateTime                  @default(now())
  updatedAt    DateTime                  @updatedAt
  networkId    Int
  network      Network                   @relation(fields: [networkId], references: [id], onUpdate: Restrict)
  userProfiles AddressesOnUserProfiles[]
  lastSynced   DateTime?
  paybuttons   AddressesOnButtons[]
  transactions Transaction[]

  @@index([networkId], map: "Address_networkId_fkey")
}

model Paybutton {
  id             String               @id @default(dbgenerated("(uuid())"))
  name           String               @db.VarChar(255)
  buttonData     String               @db.LongText
  providerUserId String?              @db.VarChar(255)
  createdAt      DateTime             @default(now())
  updatedAt      DateTime             @updatedAt
  addresses      AddressesOnButtons[]

  @@unique([name, providerUserId], map: "Paybutton_name_providerUserId_unique_constraint")
}

model AddressesOnButtons {
  paybuttonId String
  addressId   String
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  address     Address   @relation(fields: [addressId], references: [id])
  paybutton   Paybutton @relation(fields: [paybuttonId], references: [id], onDelete: Cascade)

  @@id([paybuttonId, addressId])
  @@index([addressId], map: "AddressesOnButtons_addressId_fkey")
}

model Network {
  id        Int       @id @default(autoincrement())
  slug      String    @unique @db.VarChar(255)
  title     String    @db.VarChar(255)
  ticker    String    @db.VarChar(255)
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  addresses Address[]
  prices    Price[]
}

model Transaction {
  id        String                 @id @default(dbgenerated("(uuid())"))
  hash      String                 @db.VarChar(255)
  amount    Decimal                @db.Decimal(24, 8)
  confirmed Boolean                @default(false)
  timestamp Int
  addressId String
  address   Address                @relation(fields: [addressId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  prices    PricesOnTransactions[]
  createdAt DateTime                  @default(now())
  updatedAt DateTime                  @updatedAt

  @@unique([hash, addressId], name: "Transaction_hash_addressId_unique_constraint")
  @@index([addressId], map: "Transaction_addressId_fkey")
}

model Wallet {
  id             String                    @id @default(dbgenerated("(uuid())"))
  createdAt      DateTime                  @default(now())
  updatedAt      DateTime                  @updatedAt
  name           String                    @db.VarChar(255)
  providerUserId String?                   @db.VarChar(255)
  userAddresses  AddressesOnUserProfiles[]
  userProfile    WalletsOnUserProfile?

  @@unique([name, providerUserId], map: "Wallet_name_providerUserId_unique_constraint")
}

model Quote {
  id        Int      @id @default(autoincrement())
  slug      String   @unique @db.VarChar(255)
  title     String   @db.VarChar(255)
  ticker    String   @db.VarChar(255)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  prices    Price[]
}

model Price {
  id           Int                    @id @default(autoincrement())
  value        Decimal                @db.Decimal(36, 8)
  createdAt    DateTime               @default(now())
  updatedAt    DateTime               @updatedAt
  timestamp    Int
  network      Network                @relation(fields: [networkId], references: [id], onUpdate: Restrict)
  networkId    Int
  quote        Quote                  @relation(fields: [quoteId], references: [id], onUpdate: Restrict)
  quoteId      Int
  transactions PricesOnTransactions[]

  @@unique([timestamp, quoteId, networkId], name: "Price_timestamp_quoteId_networkId_unique_constraint")
}

model PricesOnTransactions {
  priceId       Int
  transactionId String
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  price         Price       @relation(fields: [priceId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  transaction   Transaction @relation(fields: [transactionId], references: [id], onUpdate: Cascade, onDelete: Cascade)

  @@id([priceId, transactionId])
}

model AddressesOnUserProfiles {
  addressId     String
  userId String
  walletId      String?
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  address       Address     @relation(fields: [addressId], references: [id], onDelete: Cascade)
  userProfile   UserProfile @relation(fields: [userId], references: [id], onDelete: Cascade)
  wallet        Wallet?     @relation(fields: [walletId], references: [id], onDelete: SetNull)

  @@id([userId, addressId])
}

model WalletsOnUserProfile {
  walletId      String      @unique
  userId String
  isXECDefault  Boolean?
  isBCHDefault  Boolean?
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  wallet        Wallet      @relation(fields: [walletId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  userProfile   UserProfile @relation(fields: [userId], references: [id], onUpdate: Cascade, onDelete: Cascade)

  @@id([walletId, userId])
  @@unique([userId, isBCHDefault], name: "WalletsOnUserProfile_userId_isBCHDefault_unique_constraint")
  @@unique([userId, isXECDefault], name: "WalletsOnUserProfile_userId_isXECDefault_unique_constraint")
}

model UserProfile {
  id        String                    @id @db.VarChar(255)
  createdAt DateTime                  @default(now())
  updatedAt DateTime                  @updatedAt
  wallets   WalletsOnUserProfile[]
  addresses AddressesOnUserProfiles[]
}
